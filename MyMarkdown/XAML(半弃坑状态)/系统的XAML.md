## 3.1 XAML的树形结构
用户眼里的ui布局是平面的，因此对于程序员来说，其是需要设计好窗体的大小，把控件按照设计师的要求对齐地放在窗体中。
与传统的设计思维不同XAML使用树形结构来描述UI。在我们把一个XAML文件中对于属性的赋值去掉之后，我们可以很清晰的看到XAML的树形结构。
![[Pasted image 20220830142443.png]]
这样看可能还不太明显，我们还可以转换成这样：![[Pasted image 20220830142521.png]]

## 3.2XAML中为对象赋值的语法
XAML只是一种声明性语言，编译器会为每个标签创建一个与之对应的对象。对象创建出来之后要求它的属性进行必要的初始化之后才有使用意义。
**XAML中为对象属性赋值共有两种语法**
* 使用字符串进行简单的赋值
* 使用属性元素进行复杂赋值

下面以Rectangle标签的Fill属性为例
	一个标签的属性里有一部分与对象中的属性是互相对应的。对于Rectangle中的Fill来说，它和Rectangle中的Fill属性对应。在MSDN中我们可以查到其类型是Brush。那么以Brush为基础的类都可以对其进行赋值。![[Pasted image 20220830143358.png]]
	我们这里以单色刷为例。假设我们仅仅使用Blue对Fill进行赋值。那么我们只需要这么写。
	```
``` XAML

<Rectangle x:Name="rectangle" Width="200" Height="120" Fill="Blue"/>
```

我们需要注意的是，在使用这种简单的赋值方法时，鉴于XAML的语法限制，我们仅能使用一个字符串值来对属性进行赋值

属性元素：
	在XAML中，非空标签都具有自己的内容。标签内容指的是夹在起始标签和结束标签之间的一些子标签，每个子标签都是父级标签内容的一个元素。如果我们把上面的代码使用属性标签式的写法改写一下就可以得到这样的代码：
	```
```XAML

<Rectangle x:Name="rectangle" Width="200" Height="120">
        <Rectangle.Fill>
            <SolidColorBrush Color="Blue"/>
        </Rectangle.Fill>
</Rectangle>
```
效果其实和之前的简单赋值来说是没用区别的，并且也没有优势。但是遇到属性是复杂对象的时候，这种赋值的优势就体现出来了，在这里假设我们使用线性渐变画刷来填充这个矩形：
![[Pasted image 20220830145206.png]]
当然，这么冗长的代码也是存在优化的空间的。
![[Pasted image 20220830145442.png]]
简化XAML的技巧：
* 能使用简单赋值形式的就不要用属性元素
* 充分利用默认值，去除冗余。
* 充分利用XAML的简写方式

标记扩展：
	大多数赋值都是为属性生成一个新的对象。但有时候需要把同一个对象赋值给两个对象的属性，还有的时候需要给对象的属性赋一个null值，WPF甚至允许将一个对象的属性值依赖在其他对象的某个属性上。当需要为对象的属性进行这些特殊类型赋值时就需要使用标记扩展了。
	tips：![[Pasted image 20220830145932.png]]
	比如这样：
	``` <TextBox Text="{Binding ElementName=slider,Path=Value,Mode=OneWay}" Margin = "5"/>```
	其实这个和C#的对象初始化语法很相近。
	如果用C#来创建这样的一个对象，那么就是这样的：
```XAML

Binding binding = new Binding(){Source = sliderl,Mode = BindingMode.OneWay};
```  

标签扩展也是对属性的赋值，因此也可以使用属性标签的形式来替换标记拓展，只是简洁性使然没人那么做。
并不是所有的对象都能用标记扩展的语法来书写，只要MarkupExtension类的派生类才能使用标记拓展语法来创建对象。
标记拓展的tips：
![[Pasted image 20220830150933.png]]

## 3.3事件处理器与代码后置
我们知道XAML标签对应的对象，这个标签的一部分属性对应着对象中相应的属性。除了这部分属性外，标签中还有一部分属性对应着对象的事件（Event）。例如Button中有一个名为Click的属性，它对应的就是Button类的Click事件。
 在.NET事件处理机制中，可以为某个事件指定一个能与该事件匹配的成员函数，当这个事件发生时，.NET会去调用这个函数，即表示对这个事件的响应和处理。WPF支持在XAML中为对象的事件指定事件处理器，方法时使用事件处理器的函数名为对应对象事件的属性进行赋值。
 ```XAML
 
 <ClassName EventName="EventHandlerName"/>
```
当我们为一个XAML标签的事件性属性进行赋值时，XAML编辑器会自动为我们生成相应的事件处理器。我们知道C#语言编写的代码应该用于处理程序的逻辑。因此我们可以把用于实现程序逻辑的C#代码放在一个文件里，把用于描述程序UI的XAML代码放在另一个文件里，并且让事件性属性充当XAML与C#之间沟通的纽带。
![[1661844819212.png]]



## 3.4导入程序集和引用其中的名称空间
![[Pasted image 20220830153605.png]]

如何在XAML里引用类库中的名称空间和类。
假设当前我的类库程序集名为MyLibrary.dll,其中包含Common和Controls两个名称空间。在XAML中引用这两个名称空间的语法是：xmlns:映射名="clr-namespace:类库中名称空间的名字;assembly=类库文件名"
![[Pasted image 20220830154556.png]]
一旦我们将类库中的名称空间引用XAML文档，我们就可以使用这些名称空间里的类。语法格式是：
<映射名:类名>...</映射名:类名>
例如使用Common和Controls中的类，代码是这样的:
![[Pasted image 20220830154815.png]]


## 3.5XAML的注释
XAML的注释语法也继承自XML。语法是：
<!--需要被注释掉的内容-->
![[Pasted image 20220830154936.png]]
