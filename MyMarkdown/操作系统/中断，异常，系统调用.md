 ## 中断和异常处理机制

 中断是外设事件。存在硬件处理和软件处理。对于我们的操作系统来说，其会为所有产生的中断绘制一个表，并且为每一种中断标注一个标识符，这样系统就能知道当前是哪一个外设发出中断请求，并且能知晓中断地址（中断服务）。
 
 中断后软件的处理：
 * 保存当前处理状态
 * 中断服务程序处理
 * 清楚中断标记
 * 恢复之前保存的处理状态

异常：
* 保存现场
* 异常处理（杀死产生了异常的程序或重新执行异常指令）
* 恢复现场

系统调用：
	当前应用需要操作系统提供一些服务，而这些服务不能由应用程序之间执行，因此需要操作系统进行一个调用。比如在标准的C库中，应用程序调用printf()，会触发系统调用write()。
	而程序访问主要是通过高层次的API接口而不是直接进行系统调用。例如Win32 Java API等。对于操作系统而言，其一直在内核态和用户态之间进行切换。用户态下计算机仅能进行一些规定的指令，内核态下计算机可以执行任意指令。
	
系统调用和函数调用的区别
在函数调用中，函数的调用以及参数的传递是在同一个堆栈之间完成的。
而系统调用中，系统内核以及应用程序都有各自的堆栈。因此系统调用的开销比函数调用要大，但是系统调用保证了安全性。对应的开销如下：
* 建立中断/异常/系统调用号与对应服务例程映射关系的初始化开销
* 建立内核堆栈
* 验证参数
* 内核态映射到用户态的地址空间，更新页面映射权限
* 内核态独立地址空间