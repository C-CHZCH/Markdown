# 模板与泛型

> 模板就是函数的蓝图。诸如STL中的vector容器或者是容器中包含的find函数，都是与泛型相关

# 函数模板

对于复用性高的函数，我们可以设计一个函数模板，而不是一次次的编写这样的函数。

比如如下这个比较函数：

```cpp
template <typename T>
int compare(const T &a,const T &b){
    if(a>b){
        return 1;
    }
    else{
        return 0;
    }
}
```

模板定义从关键字 template 开始，使用<>包裹着参数列表。

模板形参很像函数形参。在使用的时候，模板会显示/隐式地将其绑定在相应使用的函数形参中。

在我们进行实例化时`compare(a,b)` 编译器会根据推断出的模板绑定到形参中。

### 模板类型参数

我们可以把模板看成一种特殊的数据类型，它也可以当作函数返回值

```cpp
template <typename T> compare(const T &a,const T &b){
    if(a>b){
        return a;
    }
    else{
        return b;
    }
}
```

例如如上的写法。

### 非类型模板参数

一个非类型参数表示的是一个值而不是一个类型。当一个模板被实例化之后，非类型参数被用户提供的或者编译器提供的值所替代。这些值必须是常量表达式。

假如我们需要比较两个字符串字面常量，那么我们就可以这样编写。

```cpp
#include <string.h>
template <unsigned N,unsigned M>

auto compare(const char (&p)[N],const char (&q)[M]){
    return strcmp(p,q);
}
```

- 当然，现在不会这么写，string.h已经被扫入垃圾堆，被可拷贝的string类型替代。

此模板定义了两个非类型的参数，表示两个数组的长度。

当我们调用这个版本的compare时，编译器会根据字面常量的大小来代替N和M。

一个非类型参数可以是一个整型，或者是一个指向对象的指针，又或者是一个左值引用。在需要使用常量表达式时，我们可以使用非类型参数，例如：指定数组的长度。

### inline和constexpr模板类型

函数模板可以定义为inline或者constexpr。语法如下：

```cpp
    templete<typename T> inline T min(const T&,const T&);
```

### 编写类型无关代码

从上文最简单的compare函数中不难发现，编写泛型代码具有如下两个原则：

- 模板中的函数参数是const引用
- 函数中的条件判断仅能使用<比较运算（问题就是实例化之后的类型可能不支持>运算符，一定要注意这个问题）

通过将函数参数定义为const引用，是为了保证我们的函数可以处理不能拷贝的类型。

### 函数模板错误的捕获

模板只有在实例化时才会生成代码，这一特性就说明我们只有在编译时才能发现错误。

通常编译器会抛出三个阶级的错误

- 模板内的一些语法问题，例如括号或者分割号的缺失（都是一些简单的问题）
- 编译器遇到模板使用时，编译器会检查实参数目是否正确等。
- 编译器在模板实例化时，只有这个阶段才能发现类型相关的错误。

### 模板的推导

- 在模板类型推导时，有引⽤的实参会被视为⽆引⽤，他们的引⽤会被忽略
- 对于通⽤引⽤的推导，左值实参会被特殊对待
- 对于传值类型推导，实参如果具有常量性和易变性会被忽略
- 在模板类型推导时，数组或者函数实参会退化为指针，除⾮它们被⽤于初始化引⽤

# 类模板class

类似于函数模板，类模板以关键字templete开始，后面跟着模板参数列表。在类模板中我们将模板参数当作一个”替身“，代替使用模板时用户需要提供得到类型和值。

可以看一个例子。

![Untitled](E:\MyMarkdown\C++\C艹\模板与泛型\Untitled.png)

这是一个标准的类模板。

在此类中我们有一个名为T的模板类型参数，用来保存Blob保存的元素的类型。

### 实例化类模板

我们仍然以上面的Blob模板作为一个例子

```cpp
Blob<int>a;
Blob<int>b = {0,1,2,3};
```