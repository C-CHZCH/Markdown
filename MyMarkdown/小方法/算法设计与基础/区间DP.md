# 区间动态规划
所谓的区间动态规划，就是给划定的一个区间内求取一个最优值。而这个区间的最优值又往往来自于多个这个区间的子区间的推导，进而得到整个区间的最优值。
区间 DP 的特点：

**合并**：即将两个或多个部分进行整合，当然也可以反过来；

**特征**：能将问题分解为能两两合并的形式；

**求解**：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。
典型题：
### 合并石头
来自[leetcode1000](https://leetcode.cn/problems/minimum-cost-to-merge-stones/)
在一堆石子里面每次连续取KK堆合并，求合并到最后一堆最小的合并成本。
（**全文贯彻一个思想 1 堆石头可以由很多石头组成，并不一定由一个石头组成，因此k堆石头最少k个石头组成**）
我们可以试着反着想，合并为一堆石头来源于k堆石头，而这个k堆石头是来自于1堆和“k - 1”堆石头之间的合并，**K−1堆的每一堆都可能从K堆合并而来**。因此我们可以得出这样地一个推导式：1+(1+(1+(1+Z)) 而这里面的Z一定是K-1的倍数，所以就是要有解的话，(n - 1) % (K - 1) == 0。简单理解就是除了一堆，剩下的堆数必定是K−1堆的倍数。
首先依旧是要说明动规的五步曲：
1.  确定dp数组（dp table）以及下标的含义
2.  确定递推公式
3.  dp数组如何初始化
4.  确定遍历顺序
5.  举例推导dp数组

在这里我们定义的dp数组的含义为在 i 到 j 这个区间内 合并为 k 堆的**最佳组合**。（dp[ i ][ j ][ k ]）
确定递推公式：根据我们上面的推导 合并为 1 堆石头需要 k 堆石头 ，我们就可以得到这样的一个式子`f[i][j][k] = min(f[i][j][k], f[i][m][1] + f[m + 1][j][k - 1])` 这里的m是用于在 i 到 j 这个区间内区分那边是 1 堆 哪边是 k - 1 堆。**注意此处不是合并！合并的是只有K堆才可以合并（大K不是小k）** 在这个推导式推导完的时候我们再在 f[ i ][ j ][ 1 ]的位置更新在 i 到 j 这个区间内合并 K 堆石头的时候的成本。

确定遍历顺序:
根据区间dp的套路：
先枚举区间长度lenlen,再枚举左端点ii，再枚举kk堆石子数，再枚举分界点mm，所以我们四层循环。
```cpp
for (int len = 2; len <= n; ++len) {
            for (int i = 0; i <= n - len; ++i) {
                int j = i + len - 1;
                for (int k = 2; k <= K; ++k) {
                    for (int m = i; m < j; m += K - 1) {
                        f[i][j][k] = min(f[i][j][k], f[i][m][1] + f[m + 1][j][k - 1]);
                    }
                }
                f[i][j][1] = f[i][j][K] + prefix[j + 1] - prefix[i];
            }
        }
```

在此记录一下我初次见到这个循环时的一些疑惑：
1. 为什么要遍历k。这里遍历 k 是**找最佳组合**，而不是说找最小成本！我们只有在合并 k 堆的时候才可以把成本加进去！我们这个dp数组的定义是 i 到 j 区间内 合并为 k 堆的最佳组合。理解了dp数组的定义之后，再去看看上面的推导式，就知道为什么了


dp数组的初始化，一颗石头合并为1堆的成本为0，因此
```cpp
for (int i = 0; i < n; ++i) {
            f[i][i][1] = 0;
        }
```
而在剩余的地方，为了min函数能够正常运行，我们赋予一个最大值！

贴上答案
```cpp
class Solution {
public:
    int mergeStones(vector<int>& stones, int K) {
        int n = stones.size();
        if ((n - 1) % (K - 1) != 0) return -1;
        vector<int> prefix(n + 1);
        for (int i = 1; i <= n; ++i) {
            prefix[i] = prefix[i - 1] + stones[i - 1];
        }
        vector<vector<vector<int>>> f(n, vector<vector<int>>(n, vector<int>(K + 1, 0x3f3f3f3f)));
        for (int i = 0; i < n; ++i) {
            f[i][i][1] = 0;
        }
        for (int len = 2; len <= n; ++len) {
            for (int i = 0; i <= n - len; ++i) {
                int j = i + len - 1;
                for (int k = 2; k <= K; ++k) {
                    for (int m = i; m < j; m += K - 1) {
                        f[i][j][k] = min(f[i][j][k], f[i][m][1] + f[m + 1][j][k - 1]);
                    }
                }
                f[i][j][1] = f[i][j][K] + prefix[j + 1] - prefix[i];
            }
        }
        return f[0][n - 1][1];
    }
};
```
